---
layout: post
title: CSS中Float概念
categories: [blog ]
tags: [Float ]
description: CSS中Float概念
---

**float 是 css 的定位属性。**

在传统的印刷布局中，文本可以按照需要围绕图片。一般把这种方式称为“文本环绕”。在网页设计中，应用了CSS的float属性的页面元素就像在印刷布局里面的被文字包围的图片一样。浮动的元素仍然是网页流的一部分。这与使用绝对 定位的页面元素相比是一个明显的不同。绝对定位的页面元素被从网页流里面移除了，就像印刷布局里面的文本框被设置为无视页面环绕一样。绝对定位的元素不会 影响其它元素，其它元素也不会影响它，无论它是否和其它元素挨着。

像这样在一个元素上用CSS设置浮动：

	#sidebar { float: right; }


fload属性有四个可用的值：Left 和Right 分别浮动元素到各自的方向，None (默认的) 使元素不浮动，Inherit 将会从父级元素获取float值。

**Float的用处**

除了简单的在图片周围包围文字，浮动可用于创建全部网页布局。Float对小型的布局同样有用。例如页面中的这个小区域。如果我们在我们的小头像图片上使用Float，当调整图片大小的时候，盒子里面的文字也将自动调整位置：同样的布局可以通过在外容器使用相对定位，然后在头像上使用绝对定位来实现。这种方式中，文本不会受头像图片大小的影响，不会随头像图片的大小而有相应变化。

**清除Float**

清除(clear)是浮动(float)的相关属性.一个设置了清除Float的元素不会如浮动所设置的一样，向上移动到Float元素的边界，而是会忽视浮动向下移动。要解决这个问题，可以在页脚(footer)上清除浮动，以使页脚(footer)待在浮动元素的下面。

	#footer { clear: both; }


清 除(clear)也有4个可能值。最常用的是 both，清楚左右两边的浮动。left 和 right 只能清楚一个方向的浮动。none 是默认值，只在需要移除已指定的清除值时用到。inherit 应该时第五个值，不过很奇怪的是 IE 不支持(这个不奇怪吧，IE 从来都这么特立独行吧 －糖伴西红柿注)。只清除左边或右边的浮动，实际中很少见，不过绝对有他们的用处。

**伟大的塌陷**

使用浮动(float)的一个比较疑惑的事情是他们怎么影响包含他们的父元素的。如果父元素只包含浮动元素，那么它的高度就会塌缩为零。如果父元素不包含任何的可见背景，这个问题会很难被注意到，但是这是一个很重要的问题。塌陷的直观对立面更不好，看看下面的情况：当上面的块级元素自动扩展以适应浮动元素时，段落间的文本流中会出现非自然的空白换行，而且没有有效的方法来修正这个问题。对于这种情况，设计师的抱怨会更甚于对塌陷的抱怨。为了防止怪异的布局和跨浏览器的问题，塌陷问题几乎总是被要处理的。我们在容器中的浮动元素之后，容器结束之前来清除浮动。

**清除浮动的技术**

如果你很明确的知道接下来的元素会是什么，可以使用 clear:both; 来清除浮动。这个方法很不错，它不需要 hack，不添加额外的元素也使得它有良好的语义性。当然事情并不是都可以这样解决的，工具箱中还是需要另外几个清除浮动的工具。

**空div方法**从字面来看，是一个空的 div。有时可能会用或者一些其他元素，但是 div 是最常用的，因为它没有浏览器默认样式；没有特殊功能，而且一般不会被 css 样式化。这个方法因为只是为了表现，对页面没有上下文涵义而被纯语义论者嘲笑。诚然，从严格的角度来说他们是对的，但是这个方法有效而且没有任何伤害。**overflow 方法**在父元素上设置 overflow 这个 css 属性。如果父元素的这个属性设置为 auto 或者
hidden，父元素就会扩展以包含浮动。这个方法有着较好的语义性，因为他不需要额外元素。但是，如果需要增加一个新的 div
来使用这个方法，其实就和空 div 方法一样没有语义了。而且要记住，overflow属性不是为了清除浮动而定义的。要小心不要覆盖住内容或者触发了不需要的滚动条。

**简单清除**

方法使用了一个聪明的css 伪选择符(:after)来清除浮动。比起在父元素上设置cssoverflow，只需要给它增加一个额外的类似于”clearfix”的类。这个类使用如下css:

	.clearfix:after
	{
	content: "."; visibility: hidden; display: block; height: 0; clear:
	both;}


这会在清除浮动的父元素之后应用一点看不见的内容。这不是全部内容，还需要一些额外的代码来适应那些老旧的浏览器。不同的情况需要不同的浮动清除方法。以一个具有不同样式块的网格为例。为了从视觉上较好的把相似的块联系起来，需要在必要的地方开启新行，这里是颜色改变的地方。如果每个颜色组都有一个父元素的话，我们可以使用 overflow 或者 简单清除方法。或者，在每组之间用一个空div方法。额外的 div 之前并不存在，可以自己试试来看看哪个方法好。

**浮动的问题**

浮动因脆弱而饱受诟病。大多数的脆弱性来自于 IE6 及其一系列的浮动相关 bug。因为越来越多的设计师不再支持 IE6 了，你也可以不关注它了。不过对于那些要关注的人来说，这里有些大概。

**推倒**是浮动元素内的元素（大多是图片）比浮动元素本身宽造成的现象。大多数的浏览器会在浮动之外渲染图片，但是不会有伸出来的部分影响其他布局。IE 会扩展浮动来包含图片，精彩大幅度地影响布局。一个普遍的例子是突破伸出主内容之外把侧栏推到下面。

**快速修正**：确保不是图片造成这种情况，使用 overflow:hidden 来切除多余的部分。

**双倍边距bug**处理 IE6 时，另一个需要记住的事情是，如果在和浮动方向相同的方向上设置外边距(margin)，会引发双倍边距。快速修正：给浮动设置 display:inline; 而且不用担心，它依然是块级元素。

**3像素间距**是指挨着浮动元素的文本会神奇的被踢出去3像素，好像浮动元素的周围有一个奇怪的力场一样。快速修正：在受影响的文本上设置宽度或高度。IE7 中，**底边距 bug**是当浮动父元素有浮动子元素时，这些子元素的底边距会被父元素忽略掉。快速修正：用父元素的底内补白(padding)代替。“关于图文围绕的实践可以追溯到很久很久以前。这也就是为什么从Netscape1.1开始这个功能被引入浏览器，以及为什么CSS使用浮动属性来实现它。 

‘Float(浮动)’这个术语引用自伴随Netscape1.1一同发布的‘Additions to HTML 2.0’文档，描述一个元素浮动至某一侧并停下的表现方式。”[Containing Floats]“浮动元素的定位还是基于正常的文档流，然后从文档流中抽出并尽可能远的移动至左侧或者右侧。文字内容会围绕在浮动元素周围。当一个元素从正常文档流中抽出后，仍然在文档流中的其他元素将忽略该
元素并填补他原先的空间。” [Float Positioning]“元素浮动后将自动转为块级元素。该元素可以被移动至当前行的左侧或右侧。属性如下：

	float: left,float: right or float: none”[Floatutorial: Float Basics]


“你应该为所有的浮动元素设定宽度属性（除非是＜img＞元素，因其具有隐含的宽度）。如果不设定宽度，结果将是不可预知的。

[Floatutorial: Float Basics],举例来说，浮动元素应该定义宽度属性，不论是显式指定的还是隐含的。另外，它会尽可能的水平的填充容器元素，就像非浮动内容那样，不给其他内容空间以围绕它们。其次，和正常文档流中的元素不同，浮动元素的垂直边距(margin)不会叠加。最后，浮动元素可以和临近在正常文档流中块级元素重叠（
译注：浮动元素不占任何正常文档流空间，所以建议不要理解成重叠，而是腾空浮动的概念。

[CSS Positioning: Floats],首先我们要牢记的一件事情是，浮动元素只能浮动至左侧或者右侧，没有浮动至中间一说，这是很多新手容易范的错误。记住，最基本的规则，浮动元素只能浮动至两侧。

[Float Layouts],当我们让一个元素浮动，它会往右或者往左浮动直至遇到容器的边缘。如果我们向同一方向再浮动一个元素，它会浮动直至碰到前一个浮动元素的边缘。如果我们浮动更多的元素，他们将一个挨一个排列，但不久就会空间不足，当该行已经无法容纳更多的浮动元素，则下一个浮动元素会换行继续排列。

Containing blocks or containing boxes：“容器元素是指包含其他子元素的行级或块级元素。。。。

[Floatutorial],当明确指定时，浮动元素垂直位置由它原先在文档流中的位置决定，顶端与当前行顶端对其。但是水平方向上，它尽可能远的向容器元素边缘移动，但是仍遵循容器元素的填充距离(padding)。同行的行内元素则围绕浮动元素排列。

[CSS Positioning: Floats],由于浮动元素不占据正常文档流空间，所以浮动元素前后那些未明确指定位置的块级元素会占据浮动元素本来应该处在的位置，就好像它从来不曾存在过。而浮动元素之后的那行会根据浮动元素缩小宽度。浮动元素之前的元素则会重新被排列，占据独立的一行。（译注：ie 和 ff 在这种情况下的表现不
尽相同）

[W3C Visual Formatting Model]，如果当前行的水平方向上没有足够的空间容纳浮动元素，则向下一行，直至有能容纳该元素的行。”

[Floatutorial: Float Basics],任何浮动元素都不可能超过原来所处文档留位置的上边界。浮动元素的顶端必定和当前行顶端对齐（或

者在没有当前行元素时和前一个块级元素底部边缘对齐）。

[Float Layouts]想要真正理解浮动理论，你必须明白在CSS中什么是行 (line box)。不幸的是，为了解释什么是行，你必须先明白什么是行级元素。行级元素指的是那些非块级元素，例如＜em＞而行是一个逻辑上的概念，是一个虚拟的矩形，包含了组成该行的所有行级元素，其高度至少等于这些行级元素中最高的那个。

[Float Layouts],如果我们将Div中所有的列都加上 float: left 它们会挨个向左排列，如果我们希望在页面底部有一个页脚，并不需要一个最长的列，只要加上 clear: both 就可以了。

[Float Layouts]，使用浮动元素包含浮动元素这样的布局方式有一个潜在的缺点，即你的页面是否能够一直保持一致的展现效果将取决于浏览器的实现是否保持一致。特别是当浮动元素是一个更为复杂的布局中的一部分的话，将变得更加不堪一击。

**Clearing the floats**

-------------------------------------------------------------------------------------

“浮动元素之后的元素会自动围绕该浮动元素。如果你不希望这样，你可以为这些元素应用‘clear’属性。该属性有4种设值：clear: left, clear: right, clear: both or clear: none”[Floats and “clear”]。

有很多技巧可以做到清理浮动元素，但不引入额外的无语义标签。下面3种是比较常见的做法： 

a) 将容器元素一起浮动

b) 在容器元素上使用 overflow: hidden c) 使用:after这样的css伪类。

插入一个清理元素是使容器正确包裹所有浮动元素的标准做法，这样做具有将容器底部边缘‘拖拉’以包裹所含元素的效果。 

“对于基于浮动设计的布局来说，一个常见的问题就是浮动元素的容器不会自动伸展来包含浮动元素。如果你希望在所有的浮动元素的外面加上边框（例如，在容器元素上加上边框），这样你必须显示的命令浏览器来伸展容器。你可以是用overflow method方法。”

使用:after 想像一下我们使用:after来插入一个点号，并且设置它的属性{clear: both;}。这就是所有你需要做的事情，但是没有人会接受容器底部有那么一丝空隙，所以我们还要设置{height: 0;}和{visibility: hidden;} 来保证严丝合缝。
